<!-- title -->
<section id="home">
  <!-- landing -->
  <section id="home-title">
    <h1>Cloud Native OCI</h1>
    <h2>Kubernetes/OKE</h2>
    include "partials/_titleSlide.html"
  </section>

  <!-- TOC -->
  <section id="toc">
    <h2>Table of Contents</h2>
    <ul class="plain">
      <!-- add a line for each <section id="slideId">...</section>  -->
      <li><a href="#home">Home</a></li>
      <li><a href="#lab">Lab Overview</a></li>
    </ul>
  </section>

  <!-- Contributors -->
  include "partials/_contributors.html"
</section>

<!-- Kubernetes -->
<section id="k8s_intro">
  <section>
    <h2>Kubernetes Overview</h2>
    <ul>
      <li>Architecture</li>
      <li>Building Blocks</li>
      <li>Kubernetes on OCI</li>
    </ul>
  </section>
  <section>
    <h2>Architecture</h2>
    <p class="mu-small">Kubernetes is an open-source container-orchestration system for automating
      application deployment, scaling, and management.</p>
    <img class="plain" data-src="/images/k8s/k8s_architecture.png" alt="Service" />

    <aside class="notes" data-markdown>
      Kubernetes provides a framework to run distributed systems resiliently - takes care of scaling,
      failover, deployment patterns etc.

      Features:
      - **service discovery and load balancing**: exposing containers using DNS names or IP address, distribute and load
      balance traffic, so that the deployment
      is stable
      - **storage orchestration**: mount a storage system of your choice - be it local, cloud providers, etc.
      - **automated rollouts/rollback**: define a desired state for your deployed containers, and Kubernetes will
      take care of getting from the
      current state to the desired state in a controlled way
      - **automatic bin packing**: specify memory and CPU each container needs, so kubernetes can distribute them across
      workers more efficiently
      - **self healing**: failed/crashed containers are restarted, containers that don't respond to health checks are
      killed
      - **secret and configuration management**: allows you to store and manage sensitive information - you can deploy
      and
      update your secrets without rebuilding
      the container images

      Two pieces to the Kubernetes cluster.

      **Master component**
      - makes global decisions on scheduling, responding to cluster events
      - exposes the Kubernetes API
      - contains an key value store (etcd) for stroing all cluster data
      - controller components, responsible for various resources - e.g. node controllers, replication controllers

      **Node components**
      - agent responsible for running containers and ensuring they are healthy
      - proxy that maintains network rules and allows communication between pods

    </aside>
  </section>
  <section>
    <h2>Building Blocks</h2>
    <div class="mu-flex mu-gutter">
      <div><img class="plain" data-src="/images/k8s/node_pod.png" alt="Service" /></div>
      <div><img class="plain fragment" data-src="/images/k8s/deployment.png" alt="Service" /></div>
    </div>
    <aside class="notes" data-markdown>
      The basic building block of Kubernetes is a Pod.

      Pod is the smallest deployable unit and it's a group of one or more Docker containers that share storage and
      network. All containers within a Pod share an IP and port space and can find each other via localhost.
    </aside>
  </section>
  <section>
    <h2>Building Blocks</h2>
    <div class="mu-flex mu-gutter">
      <ul>
        <li class="fragment">ClusterIP</li>
        <li class="fragment">NodePort</li>
        <li class="fragment">LoadBalancer</li>
      </ul>
      <div><img class="plain" data-src="/images/k8s/service2.png" alt="Service" /></div>
      <aside class="notes" data-markdown>
        Pods have unique IP address, however, pods are also ephemeral, they can get killed and rescheduled, meaning that
        each time that happens, pod gets a new IP address.

        Therefore you cannot rely on the pods IP address, and this is where Kubernetes Service resource comes into
        play.

        A Kubernetes **Service** defines a logical set of pods and a policy by which to access them. The set of pods a
        service targets is
        determined by a selector. For example, you can say that service "hello-world" targets all pods with a label
        "app=helloworld" set.

        Types of services in Kubernetes.

        **ClusterIP**
        Default service type - exposes the service on a cluster-internal IP only.

        **NodePort**
        Node port type exposes a service on a static port on each Node. If you have 5 nodes, your service will be
        accessible on the same port on eacch of those nodes.

        **LoadBalancer**
        This type exposes the service using a cloud providers locad balancer. Practially, this means that if I create a
        service with a LoadBalancer type on OCI, a Load balancer resource will be created for me.

      </aside>

    </div>
  </section>
  <section>
    <h2>Building Blocks</h2>
    <div class="mu-flex mu-gutter">
      <div><img class="plain" data-src="/images/k8s/configmap.png" alt="Service" /></div>
      <div><img class="plain fragment" data-src="/images/k8s/secret.png" alt="Service" /></div>
    </div>

    <aside class="notes" data-markdown>
      The other commonly used Kubernetes resources are ConfigMaps and Secrets.

      A config map can be used to store configuration settings - these could be simple literal values
      or whole files. Reason to use config maps is so you don't bake any configuration settings inside your containers,
      instead you
      should make the containers be configurable.

      Similar resource called Secrets can be used to store and manage sensitive information. Storing information in a
      secret is safer and more flexible that putting it in a pod definition or baking it inside the image.
    </aside>

  </section>
  <section>
    <h2>Building Blocks</h2>
    <div>
      <div><img class="plain" data-src="/images/k8s/pv.png" alt="Service" /></div>
    </div>

    <aside class="notes" data-markdown>
      Other resources in Kubernetes:

      **Namespaces** allow you to logically separate resources. For example, you can create namespaces for each
      developer or
      per team, or per project and so on.
      You can also define quotas on the namespaces - meaning that namespace A can only use 5 GB or memory and 5 CPUs
      etc.

      **Persistent Volume** is a piece of storage in the cluster that has been provisioned by an administrator and it
      abstracts the details of how storage is provided and consumed.

      **Persistent volume claim** represents a request for storage by a user. It's similar to a pod. Pods consume node
      resources and persistent volume claims consume PersistentVolume resources.
    </aside>
  </section>
  <section>
    <h2>Kubernetes on OCI</h2>
    <img class="plain" data-src="/images/k8s/k8s_architecture.png" alt="Service" />
    <ul class="mu-small">
      <li class="fragment">Manage upgrades of master and worker nodes</li>
      <li class="fragment">Figure out container networking and storage</li>
      <li class="fragment">Manage access to cluster</li>
    </ul>
  </section>
  <section>
    <h2>Oracle Container Engine for Kubernetes (OKE)</h2>
    Managed Kubernetes Services (CaaS)
    <img class="plain" data-src="/images/k8s/oracle_managed.png" alt="Service" />
  </section>
  <section>
    <h2>Oracle Container Engine for Kubernetes (OKE)</h2>
    <img class="plain" data-src="/images/k8s/oke_ha.png" alt="Service" />
  </section>
  <section>
    <h2>In-place upgrade - master nodes</h2>
    <img class="plain" data-src="/images/k8s/oke_ha.png" alt="Service" />
  </section>
  <section>
    <h2>In-place upgrade - worker nodes</h2>
    <img class="plain" data-src="/images/k8s/oke_ad_nodepools.png" alt="Service" />
  </section>
  <section>
    <h2>Deployment Manifests</h2>
    <pre><code class="fragment hljs sql mu-small">
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: api
  labels:
    name: api
    layer: client
spec:
  replicas: 1
  template:
    metadata:
      labels:
        name: api
        layer: client
    spec:
      containers:
      - name: api
        image: phx.ocir.io/intvravipati/mushop/api:1
        imagePullPolicy: Always
        ports:
        - name: http
          containerPort: 3000
        env:
        - name: SESSION_REDIS
          value: session
        resources:
          limits:
            cpu: 300m
            memory: 1000Mi
          requests:
            cpu: 100m
            memory: 300Mi
        securityContext:
          runAsNonRoot: true
          runAsUser: 10001
          capabilities:
            drop:
              - all
            add:
              - NET_BIND_SERVICE
          readOnlyRootFilesystem: true
        livenessProbe:
          httpGet:
            path: /health
            port: http
        readinessProbe:
          httpGet:
            path: /health
            port: http
          </code></pre>
  </section>
  <section>
    <h2>The Problem</h2>
    <ul>
      <li>Steep learning curve when implementing Kubernetes</li>
      <li>Increased complexity of microservice environments</li>
      <li>Manual application deployment using kubectl</li>
      <li>Kubernetes treats your application as a number of decoupled resources</li>
      <li>More deployment steps means more chances for human error</li>
      <li>Hard to share and distribute microservice applications</li>
      <li>Hard to manage application releases</li>
    </ul>
  </section>
  <section>
    <h2>The Solution: Helm</h2>
    <ul>
      <li>Package management tool for Kubernetes</li>
      <li>A CNCF project</li>
      <li>A package manager similar to <code>yum</code>, <code>brew</code>, <code>apt-get</code>, <code>npm</code>,
        <code>choco</code>, etc., but
        specifically
        for
        Kubernetes</li>
      <li>Method for repeatable application installation, configuration, and versioning through the
        use of charts, repositories, and releases</li>
      <li>Repository of existing templates for standard software</li>
    </ul>
  </section>
  <section>
    <h2>Helm</h2>
    <img class="plain" data-src="/images/helm/helm.png" alt="Helm" />
  </section>
</section>

<!-- Lab -->
<section id="lab">
  <section>
    <h2>Lab Overview</h2>
    <ul>
      <li>Switch context</li>
      <li>Change default namespace</li>
      <li>Create a deployment</li>
      <li>Verify</li>
    </ul>
  </section>
  <section>
    <h3>Step 1: Switch context</h3>
    <p class="mu-left">
      You will perform the tasks for the lab in the OKE cluster you created.
      To switch to that cluster use Docker desktop
    </p>
    <img class="plain" width=40% data-src="/images/k8s/switch_context2.png" alt="Helm" />
  </section>

  <section>
    <h3>Step 2: Change the default namespace</h3>
    <p class="mu-left">
      Change your default namespace to your name to avoid having to add
      <code>--namespace your-name</code> to every kubectl command.
    </p>
    <pre><code class="hljs text">kubectl config set-context $(kubectl config current-context) --namespace=your-name</code></pre>
    <p class="mu-left">To validate it:</p>
    <pre><code class="hljs text">kubectl config view | grep namespace:</code></pre>
  </section>
  <section>
    <h3>Step 3: Create a deployment</h3>
    <p class="mu-left">
      Next, you will use Helm to deploy Mushop to your namespace within an OKE cluster
    </p>
    <pre><code class="hljs text">helm install deploy/helm-chart/mushop \
        --name mushop \
        --set global.mock.service="all" \
        --set ingress.enabled=false
</code></pre>
  </section>
  <section>
    <h3>Step 4: Verify</h3>
    <p class="mu-left">
      Run the command below to check that all resources have been created:
    </p>
    <pre><code class="hljs text">kubectl get pod --watch </code></pre>
    <p class="mu-left">
      Proxy from your machine to the Edge service running in OKE:
    </p>
    <pre><code class="hljs text">kubectl port-forward svc/mushop-edge 8000:80</code></pre>
    <p class="mu-left">
      You are done! To access the store click <a href="http://localhost:8000">here</a>
    </p>
  </section>
</section>