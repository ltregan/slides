<!-- title -->
<section>
  <!-- landing -->
  <section id="home">
    <h1>Cloud Native OCI</h1>
    <h2>Kubernetes/OKE</h2>
    include "partials/_titleSlide.html"
  </section>

  <!-- TOC -->
  <section id="toc">
    <h2>Table of Contents</h2>
    <ul class="plain">
      <!-- add a line for each <section id="slideId">...</section>  -->
      <li><a href="#home">Home</a></li>
      <li><a href="#lab">Lab Overview</a></li>
    </ul>
  </section>
</section>

<!-- Kubernetes -->
<section id="k8s_intro">
  <section>
    <h2>Kubernetes Overview</h2>
    <ul>
      <li>Architecture</li>
      <li>Building Blocks</li>
      <li>Kubernetes on OCI</li>
    </ul>
  </section>
  <section>
    <h2>Architecture</h2>
    <p class="mu-small">Kubernetes is an open-source container-orchestration system for automating
      application deployment, scaling, and management.</p>
    <img class="plain" data-src="/images/k8s/k8s_architecture.png" alt="Service" />

    <aside class="notes" data-markdown>
      Kubernetes provides a framework to run distributed systems resiliently - takes care of scaling,
      failover, deployment patterns etc.

      Features:
      - **service discovery and load balancing**: exposing containers using DNS names or IP address, distribute and load
      balance traffic, so that the deployment
      is stable
      - **storage orchestration**: mount a storage system of your choice - be it local, cloud providers, etc.
      - **automated rollouts/rollback**: define a desired state for your deployed containers, and Kubernetes will
      take care of getting from the
      current state to the desired state in a controlled way
      - **automatic bin packing**: specify memory and CPU each container needs, so kubernetes can distribute them across
      workers more efficiently
      - **self healing**: failed/crashed containers are restarted, containers that don't respond to health checks are
      killed
      - **secret and configuration management**: allows you to store and manage sensitive information - you can deploy
      and
      update your secrets without rebuilding
      the container images

      Two pieces to the Kubernetes cluster.

      **Master component**
      - makes global decisions on scheduling, responding to cluster events
      - exposes the Kubernetes API
      - contains an key value store (etcd) for stroing all cluster data
      - controller components, responsible for various resources - e.g. node controllers, replication controllers

      **Node components**
      - agent responsible for running containers and ensuring they are healthy
      - proxy that maintains network rules and allows communication between pods

    </aside>
  </section>
  <section>
    <h2>Building Blocks</h2>
    <div class="mu-flex mu-gutter">
      <div><img class="plain" data-src="/images/k8s/node_pod.png" alt="Service" /></div>
      <div><img class="plain fragment" data-src="/images/k8s/deployment.png" alt="Service" /></div>
    </div>
    <aside class="notes" data-markdown>
      The basic building block of Kubernetes is a Pod.

      Pod is the smallest deployable unit and it's a group of one or more Docker containers that share storage and
      network. All containers within a Pod share an IP and port space and can find each other via localhost.
    </aside>
  </section>
  <section>
    <h2>Building Blocks</h2>
    <div class="mu-flex mu-gutter">
      <ul>
        <li class="fragment">ClusterIP</li>
        <li class="fragment">NodePort</li>
        <li class="fragment">LoadBalancer</li>
      </ul>
      <div><img class="plain" data-src="/images/k8s/service2.png" alt="Service" /></div>
      <aside class="notes" data-markdown>
        Pods have unique IP address, however, pods are also ephemeral, they can get killed and rescheduled, meaning that
        each time that happens, pod gets a new IP address.

        Therefore you cannot rely on the pods IP address, and this is where Kubernetes Service resource comes into
        play.

        A Kubernetes **Service** defines a logical set of pods and a policy by which to access them. The set of pods a
        service targets is
        determined by a selector. For example, you can say that service "hello-world" targets all pods with a label
        "app=helloworld" set.

        Types of services in Kubernetes.

        **ClusterIP**
        Default service type - exposes the service on a cluster-internal IP only.

        **NodePort**
        Node port type exposes a service on a static port on each Node. If you have 5 nodes, your service will be
        accessible on the same port on eacch of those nodes.

        **LoadBalancer**
        This type exposes the service using a cloud providers locad balancer. Practially, this means that if I create a
        service with a LoadBalancer type on OCI, a Load balancer resource will be created for me.

      </aside>

    </div>
  </section>
  <section>
    <h2>Building Blocks</h2>
    <div class="mu-flex mu-gutter">
      <div><img class="plain" data-src="/images/k8s/configmap.png" alt="Service" /></div>
      <div><img class="plain fragment" data-src="/images/k8s/secret.png" alt="Service" /></div>
    </div>

    <aside class="notes" data-markdown>
      The other commonly used Kubernetes resources are ConfigMaps and Secrets.

      A config map can be used to store configuration settings - these could be simple literal values
      or whole files. Reason to use config maps is so you don't bake any configuration settings inside your containers,
      instead you
      should make the containers be configurable.

      Similar resource called Secrets can be used to store and manage sensitive information. Storing information in a
      secret is safer and more flexible that putting it in a pod definition or baking it inside the image.
    </aside>

  </section>
  <section>
    <h2>Building Blocks</h2>
    <div>
      <div><img class="plain" data-src="/images/k8s/pv.png" alt="Service" /></div>
    </div>

    <aside class="notes" data-markdown>
      Other resources in Kubernetes:

      **Namespaces** allow you to logically separate resources. For example, you can create namespaces for each
      developer or
      per team, or per project and so on.
      You can also define quotas on the namespaces - meaning that namespace A can only use 5 GB or memory and 5 CPUs
      etc.

      **Persistent Volume** is a piece of storage in the cluster that has been provisioned by an administrator and it
      abstracts the details of how storage is provided and consumed.

      **Persistent volume claim** represents a request for storage by a user. It's similar to a pod. Pods consume node
      resources and persistent volume claims consume PersistentVolume resources.
    </aside>
  </section>
  <section>
    <h2>Kubernetes on OCI</h2>
    <img class="plain" data-src="/images/k8s/k8s_architecture.png" alt="Service" />
    <ul class="mu-small">
      <li class="fragment">Manage upgrades of master and worker nodes</li>
      <li class="fragment">Figure out container networking and storage</li>
      <li class="fragment">Manage access to cluster</li>
    </ul>
  </section>
  <section>
    <h2>Oracle Container Engine for Kubernetes (OKE)</h2>
    Managed Kubernetes Services (CaaS)
    <img class="plain" data-src="/images/k8s/oracle_managed.png" alt="Service" />
  </section>
  <section>
    <h2>Oracle Container Engine for Kubernetes (OKE)</h2>
    <img class="plain" data-src="/images/k8s/oke_ha.png" alt="Service" />
  </section>
  <section>
    <h2>In-place upgrade - master nodes</h2>
    <img class="plain" data-src="/images/k8s/oke_ha.png" alt="Service" />
  </section>
  <section>
    <h2>In-place upgrade - worker nodes</h2>
    <img class="plain" data-src="/images/k8s/oke_ad_nodepools.png" alt="Service" />
  </section>
  <section>
    <h2>Deployment Manifests</h2>
    <p class="mu-small">
    Shown below is a simple deployment manifest for the MuShop <code>storefront</code> service
    </p>
    <pre><code class="fragment hljs yaml mu-small">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: storefront
  labels:
    app.kubernetes.io/name: storefront
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: storefront
  template:
    metadata:
      labels:
        app.kubernetes.io/name: storefront
    spec:
      containers:
        - name: storefront
          image: "iad.ocir.io/oracle/ateam/mushop-storefront:2.0.0"
          ports:
            - name: http
              containerPort: 8080
            - name: status
              containerPort: 8888
          livenessProbe:
            httpGet:
              path: /
              port: http
          readinessProbe:
            httpGet:
              path: /
              port: http
          volumeMounts:
          - mountPath: /tmp
            name: tmp-volume
          resources:
            limits:
              cpu: 300m
              memory: 300Mi
            requests:
              cpu: 100m
              memory: 100Mi
            
          securityContext:
            capabilities:
              add:
              - NET_BIND_SERVICE
              - CHOWN
              - SETGID
              - SETUID
              drop:
              - all
            readOnlyRootFilesystem: true
            runAsNonRoot: true
            runAsUser: 10001
            
      volumes:
        - name: tmp-volume
          emptyDir:
            medium: Memory</code></pre>
  </section>
  <section>
    <h2>The Problem</h2>
    <ul class="mu-medium">
      <li>Steep learning curve when implementing Kubernetes</li>
      <li>Increased complexity of microservice environments</li>
      <li>Manual application deployment using kubectl</li>
      <li>Kubernetes treats your application as a number of decoupled resources</li>
      <li>More deployment steps means more chances for human error</li>
      <li>Hard to share and distribute microservice applications</li>
      <li>Hard to manage application releases</li>
    </ul>
  </section>
  <section>
    <h2>The Solution: Helm</h2>
    <ul class="mu-medium">
      <li>Package management tool for Kubernetes</li>
      <li>A CNCF project</li>
      <li>A package manager similar to <code>yum</code>, <code>brew</code>, <code>apt-get</code>, <code>npm</code>,
        <code>choco</code>, etc., but
        specifically
        for
        Kubernetes</li>
      <li>Method for repeatable application installation, configuration, and versioning through the
        use of charts, repositories, and releases</li>
      <li>Repository of existing templates for standard software</li>
    </ul>
  </section>
  <section>
    <h2>Helm</h2>
    <img class="plain" data-src="/images/helm/helm.png" alt="Helm" />
  </section>
</section>

<!-- Lab -->
<section id="lab">
  <section id="lab">
    <h2>Lab Overview</h2>
    <ul>
      <li>Set Kubernetes context</li>
      <li>Change default namespace</li>
      <li>Create a deployment with Helm</li>
      <li>Verify</li>
    </ul>
  </section>

  <section id="exercise">
    <h2>Deploy MuShop</h2>
    <div class="mu-flex mu-small switcher">
      <ul>
        <li class="fragment">Set K8s Context</li>
        <li class="fragment">Change Namespace</li>
        <li class="fragment">Deploy with Helm</li>
        <li class="fragment">Open App</li>
        <li class="fragment">Under the Hood</li>
      </ul>
      <ul class="col-1-1">
        <!-- context -->
        <li>
          If available, you may wish to perform these tasks in 
          an OKE cluster instead of a local cluster. <span class="mu-muted">OPTIONAL</span>
          <hr/>
          <div class="mu-flex mu-gutter mu-flex-stretch">
            <div class="col-1-2">
              <p>Use Docker Desktop UI:</p>
              <img class="no-margin" data-src="/images/k8s/switch_context2.png" alt="k8s switch" />
            </div>
            <div class="mu-valign mu-muted no-wrap">- OR -</div>
            <div class="col-1-2">
              <p>Use the command line:</p>
              <pre><code class="hljs text">kubectl config get-contexts</code></pre>
              <pre><code class="hljs text">kubectl config use-context &lt;name&gt;</code></pre>
              <blockquote class="mu-small">
                <b>TIP:</b> use <a href="https://github.com/ahmetb/kubectx" target="_blank">kubectx</a>
                to switch context easily &amp; often from the command line
              </blockquote>
            </div>
          </div>
        </li>
        <!-- namespace -->
        <li>
          Change your default namespace to your name to avoid having to add
          <code>--namespace &lt;name&gt;</code> to every kubectl command.
          <hr />
          <pre><code class="hljs text">kubectl create namespace mushop</code></pre>
          <pre><code class="hljs text">kubectl config set-context \
  --current --namespace=mushop</code></pre>
          <blockquote class="mu-small">
            <b>TIP:</b> use <a href="https://github.com/ahmetb/kubectx" target="_blank">kubens</a>
            to switch namespace easily &amp; often from the command line
          </blockquote>
        </li>
        <!-- deploy -->
        <li>
          Remembering that <code>helm</code> provides a way of packaging and deploying <em>configurable</em>
          charts, next we will deploy the application in <em>"mock mode"</em> where cloud services are
          mocked, yet the application is fully functional
          <hr />
          <p>
            ⚠️ <b>NOTE:</b> Ensure <a href="/workshop/setup.html#setup" target="_blank">setup</a>
            steps were completed, and prior installations are removed
          </p>
          <pre><code class="hljs sh">helm install deploy/complete/helm-chart/mushop \
  --name mushop \
  --set global.mock.service="all"</code></pre>
          <div class="mu-small mu-margin"><pre><code class="hljs text">########################################
    __  __        _____ _                 
  |  \/  |      / ____| |                
  | \  / |_   _| (___ | |__   ___  _ __  
  | |\/| | | | |\___ \| '_ \ / _ \| '_ \ 
  | |  | | |_| |____) | | | | (_) | |_) |
  |_|  |_|\__,_|_____/|_| |_|\___/| .__/ 
                                  | |    
                                  |_|    
########################################</code></pre>
          </div>
          <pre><code class="hljs text">kubectl get pod --watch</code></pre>
          <blockquote class="mu-small">
            ⏲️ It may take a few moments to download all the application images.
            It is also normal for some pods to show errors in mock mode.
          </blockquote>
        </li>
        <!-- launch -->
        <li>
          After inspecting the resources created with <code>helm install</code>,
          go ahead and launch the application in your browser.
          <hr/>
include "_openmushop.html"
        </li>
        <li>
          To get a beter look at all the installed Kubernetes manifests by
          using the <b><code>template</code></b> command:
          <hr>
          <pre><code class="hljs text">mkdir ./out</code></pre>
          <pre><code class="hljs text">helm template deploy/complete/helm-chart/mushop \
  --name mushop \
  --set global.mock.service="all" \
  --output-dir ./out</code></pre>
          Explore the files, and see each output. Example:
          <div class="mu-medium">
          <pre class="mu-ratio mu-ratio-5-2"><code class="hljs yaml"># Source: mushop/charts/api/templates/api-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mushop-api
  labels:
    app.kubernetes.io/name: api
    helm.sh/chart: api-0.1.0
    app.kubernetes.io/instance: mushop
    layer: client
    app.kubernetes.io/version: "0.1.0"
    app.kubernetes.io/managed-by: Tiller
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: api
      app.kubernetes.io/instance: mushop
      layer: client
  template:
    metadata:
      labels:
        app.kubernetes.io/name: api
        app.kubernetes.io/instance: mushop
        layer: client
    spec:
      containers:
        - name: api
          image: "iad.ocir.io/oracle/ateam/mushop-api:2.0.0"
          imagePullPolicy: Always
          ports:
            - name: http
              containerPort: 3000
          env:
          - name: MOCK_MODE
            value: "all"
          - name: SESSION_REDIS
            value: mushop-session
          - name: CATALOGUE_URL
            value: http://mushop-catalogue
          - name: ORDERS_URL
            value: http://mushop-orders
          - name: CARTS_URL
            value: http://mushop-carts
          - name: USERS_URL
            value: http://mushop-user
          - name: STATIC_MEDIA_URL
            value: ""
          livenessProbe:
            httpGet:
              path: /health
              port: http
          readinessProbe:
            httpGet:
              path: /health
              port: http
          resources:
            limits:
              cpu: 300m
              memory: 300Mi
            requests:
              cpu: 100m
              memory: 100Mi
            
          securityContext:
            capabilities:
              add:
              - NET_BIND_SERVICE
              drop:
              - all
            readOnlyRootFilesystem: true
            runAsNonRoot: true
            runAsUser: 10001</code></pre>
          </div>
        </li>
      </ul>
    </div>
  </section>
</section>